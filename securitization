##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
###################################################### START OF CODE #############################################################
######################################################  09/26/2012   #############################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################



#This code has been prepared to support the simulations presented in the paper "Commercializing biomedical research through securitization tecniques" (Jose-Maria Fernandez, Roger M. Stein, Andrew W.Lo; Nature Biotechnology; 2012). We want to thank Lloyd Han, James Noraky, Allister Bernard and Ashutosh Singhal for their excellent coding support work. 


#This is the main function that simulates all the cash flows generated by the transition of the compounds purchased and financed. It starts by defining all the variables of the model and it #also defines eight nested functions that use these variables

simulate.CFs.fn<-function(init=T,show.progress=T,debugging=0)

#This is the main function that simulates the evolution of compounds and its cash flows. 
#It starts by initializing the parameters and variables used in the simulation
#It includes some nested functions that use these variables

{
	if(init) params<<-init.params.fn()
	if(show.progress) prog.bar.click<-round(params$simu$NSIMUS/10,0)
	
    #-- global variabls & constants ---
    
   	NSIMUS<-params$simu$NSIMUS
   	NPERS<- params$simu$TIMESTEPS
   	HORIZON <-NPERS+ceiling(max(params$assets$sale.time))
   	TIMESTEPS<-params$simu$TIMESTEPS
   	NCOMPOUNDS<-sum(params$simu$initial.compounds) 
	ALL.POSSIBLE.STATES<-c("DSC","PRE","P1","P2","P3","NDA","APP")
	NSTATES<-length(params$simu$initial.compounds) 
	NBONDS<-length(params$bonds$capital.structure)-1
	STARTING.STATES<-rep("DSC", params$simu$initial.compounds[1]) 
	AMORT.SCHED<-matrix(0,NBONDS,NPERS)
	
	
	SELL.TO.COVER.FUNDING<-F

	for(i in 2:NSTATES)
	{
		phase<-ALL.POSSIBLE.STATES[i]
		STARTING.STATES<-c(STARTING.STATES,rep(phase,params$simu$initial.compounds[i]))
	}
	temp.bond.value<-params$bonds$nominal
	for (i in 1:NPERS)
	{    
		for(b in 1:NBONDS)
		{
			timing<-params$bonds$amort.timing
			AMORT.SCHED[b,i]<-calc.amort.pmt.due.fn(i,timing[b,"start"],timing[b,"stop"],params$bonds$nominal[b], temp.bond.value[b])
			temp.bond.value[b]<-temp.bond.value[b] - AMORT.SCHED[b,i]
		}
	}

    # ----------------------------------

	rho<-params$assets$rho
	bond.value<-params$bonds$nominal
   	initial.compounds<-params$simu$initial.compounds

	invested   <-rep(T,NCOMPOUNDS)
	sell.value<-rep(0,NCOMPOUNDS)
	equity.in.compound<-rep(params$assets$equity.stake,NCOMPOUNDS)
	compounds <-STARTING.STATES
	time.in.phase<-rep(0,NCOMPOUNDS)
	first.cash<-params$simu$initial.cash
	temp.bond.value<-bond.value
			
	# state of securities
	cash			  	  <-c(first.cash,rep(0, HORIZON-1))
	missed.int		  <-rep(0,length(params$bonds$nominal))
	IC.ratio           <-matrix(0,length(params$bonds$nominal), NPERS)
	IC.shortfall       <-matrix(0,length(params$bonds$nominal), NPERS)
	
	#record keeping 
	sales<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.POSSIBLE.STATES)) 
	withdrawals<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.POSSIBLE.STATES)) 
	initial.compounds<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.POSSIBLE.STATES)) 
	sale.times<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	withdrawal.times<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	compounds.to.fund<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	compounds.funded<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	extra.cash.from.coverage	<-matrix(0,NSIMUS,HORIZON) 
	cash.for.investment     <-matrix(0,NSIMUS,NPERS)
	interest.paid	  <-matrix(0,length(params$bonds$nominal), NPERS)
	principal.paid   <-matrix(0,length(params$bonds$nominal), NPERS)
	history.service		    <-matrix(0,NSIMUS)
	cash.realized	  <-matrix(0,NSIMUS,HORIZON)
	compounds.bought <-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.POSSIBLE.STATES)) 
	cash.begin.per<-matrix(0,NSIMUS,HORIZON)
	A1.realized.vals<-matrix(0,NSIMUS,NPERS)
	A2.realized.vals<-matrix(0,NSIMUS,NPERS)
	A1.paid<-matrix(0,NSIMUS,NPERS)
	A2.paid<-matrix(0,NSIMUS,NPERS)
	A1.defaults<-rep(T, NSIMUS)
	A2.defaults<-rep(T, NSIMUS)
	return.on.equity<-rep(0,NSIMUS)
	final.compounds<-matrix(0,1, NSTATES,dimnames=list(rep("a",1),ALL.POSSIBLE.STATES)) 
	
	unpaid.svc<-0
	in.default<-F
	
	invest.cost<-apply(t(compounds),2,trial.cost.fn)
	
	
	cash.left.to.spend<- cash[1] - params$bonds$IC.pers*params$bonds$nominal[1]*params$bonds$coupon[1] -params$bonds$IC.pers*params$bonds$nominal[2]*params$bonds$coupon[2] 
	# number of compounds we actually buy per phase
	num.compounds <- rep(0,NSTATES)
	
	psindx<-phase2index.fn(params$assets$sell.in.phase)-1
	

	for(i in 1:NCOMPOUNDS) 
	{
		cindx <- phase2index.fn(compounds[i])
				price.tmp<- invest.cost[i]+params$assets$pricing.params[cindx,"UpFront"]
		# If we have enough cash, buy it and update our initial cash
		if(psindx<1) FutureCostEst<-0
		else FutureCostEst<-params$assets$pricing.params[cindx,"FutureCostEst"]-params$assets$pricing.params[psindx,"FutureCostEst"]
		if (cash.left.to.spend >= price.tmp + FutureCostEst)
		{
			cash.left.to.spend <- cash.left.to.spend - price.tmp - FutureCostEst
			cash[1]<-cash[1] - price.tmp
			num.compounds[cindx]<- num.compounds[cindx] + 1
		}
		else compounds[i]<-"DSC"
	}	
			
		
	#----------------------------------    
    #- functions that use global vars - 
	#----------------------------------
	
	check.for.transitions.ffn<-function(j,rho=0,z=0)
	{
		if (compounds[j] != "DSC" && compounds[j] != "APP" && compounds[j] != "SLD" && invested[j]==T)
		{
			phase.idx<-phase2index.fn(compounds[j])
			if(debugging>2) cat("                check transition on compound[",j,"] (",compounds[j],")\n")
			p<-runif(1)
			if(debugging>2) cat("                p=",p,"\n")
			next.phase<-determine.current.state.fn(p,params$assets$trans.prob[phase.idx,])
			compounds[j]<<-next.phase
			if(debugging>2) cat("                phase index:", phase.idx,"; next phase:",next.phase,"\n")
		}
		return(NULL)
	}
	
	#----------------------------------
	
	sell.compound.ffn<-function(comp.idx,cur.per)
	{

		if(compounds[comp.idx]=="DSC" || compounds[comp.idx]=="SLD") return(NULL)
		phase.idx<-phase2index.fn(compounds[comp.idx])
		if(debugging>2) cat("phase.idx=",phase.idx,"comp.idx=",comp.idx," compound=",compounds[comp.idx],"\n")
		sale.per<-min(cur.per+ceiling(params$assets$sale.time[phase.idx]), HORIZON)
		mx<-params$assets$pricing.params[phase.idx,"vmx"]
		mu   <-params$assets$pricing.params[phase.idx,"vmu"]
		sigma<-params$assets$pricing.params[phase.idx,"vsigma"]
		price<-compound.sale.price.fn(compounds[comp.idx],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[comp.idx]
		# here is where we adjust for uninvested compounds
		if (!invested[comp.idx])
		{
			price<-max(price-invest.cost[comp.idx],0)			
		}
		# update main function vars
		sell.value[comp.idx]<<-price
		if (debugging>2) cat("sale price=",price,"\n" )
		sales[s,phase.idx]<<-sales[s,phase.idx] + 1
		
		sale.times[s,cur.per]<<-sale.times[s,cur.per]+1
        
		cash[sale.per]<<-cash[sale.per] + sell.value[comp.idx]
		if (debugging>2) cat("cur per=",cur.per,"sell.value=",sell.value[comp.idx]," sale.per=",sale.per,"\n cash:",cash,"\n")

		compounds[comp.idx]<<- "SLD"
		time.in.phase[comp.idx]<<-0
		
		return(NULL)
	}
	
	#----------------------------------

	withdraw.compound.ffn<-function(old.phase,cur.per)
	{
		# update main function vars
		withdrawals[s,old.phase]<<-withdrawals[s,old.phase]+1
		withdrawal.times[s,i]<<-withdrawal.times[s,i]+1		
		return(NULL)
	}

	#----------------------------------

	transition.compound.ffn<-function(idx)
	{
		if (compounds[idx]=="NDA")
		{
			invested[idx]<<-T	
		}
		else
		{
			invested[idx]<<-F 
		}
		cindx<-phase2index.fn(compounds[idx])
		invest.cost[idx]<<-trial.cost.fn(compounds[idx])+params$assets$pricing.params[cindx,"Milestone"]
		time.in.phase[idx]<<-0
	}

	#----------------------------------

	calc.svc.due.this.per.ffn<-function(values)
	{
		svc.due.this.per<-params$bonds$servicing.rate*sum(values)
		return(svc.due.this.per)
	}
	#----------------------------------
	
	pay.servicing.ffn<-function()
	{
		svc.OK<-T
		if (!in.default)
		{
			svc.due.this.per<-calc.svc.due.this.per.ffn(bond.value)
			svc.past.due<-unpaid.svc*(1+params$bonds$svc.accrual.int.rate)
			svc.due<-svc.due.this.per+svc.past.due
			svc.paid<-min(svc.due,current.cash)
			if(svc.paid<svc.due) svc.OK<-F
			if(debugging>1) cat(
			"               svc due this per:",svc.due.this.per,"svc.past.due:", svc.past.due," svc.due: ",
							svc.due," svc.paid: ",svc.paid," current.cash:", current.cash,ifelse(svc.OK,
							" default=F"," default=T"),"\n")
		
			# update main function vars
			history.service[s]<<-history.service[s]+svc.paid
			unpaid.svc<<-round((svc.due-svc.paid),5)
			current.cash<<-current.cash-svc.paid
		}
		return(svc.OK)
	}

	#----------------------------------
	
	ic.test.result.ffn<-function(b,i,current.cash)
	{
		if (i !=NPERS)
		{
			sched.svc<-unpaid.svc
			bv<-bond.value[b]
			K<-current.cash
			if(b>1) 
			{ 
				for(bb in 1:(b-1))
				{
					btemp<-bond.value[bb]
					
					N<-min(params$bonds$IC.per,NPERS-i)
					for(m in 1:N)
					{
						K<-K-AMORT.SCHED[bb,i+m]-params$bonds$coupon[bb]*btemp-params$bonds$servicing*btemp
						btemp<-btemp-AMORT.SCHED[bb,i+m]
					}
				}
			}	
			sched.P <- 0
			sched.I <- 0
			for(m in 1:params$bonds$IC.pers)
			{
				sched.P<- sched.P + AMORT.SCHED[b,i+m]
				sched.I<- sched.I + params$bonds$coupon[b]*bv
				sched.svc<-sched.svc+params$bonds$servicing*bv
				bv<-bv-AMORT.SCHED[b,i+m]		
			}
			cash.due<-sched.P+sched.I+sched.svc
			IC.ratio<-K/cash.due
		}
		else
		{
			IC.ratio<-params$bonds$interest.coverage[b]
		}
		return(IC.ratio)
	}
	
	#----------------------------------	
	
	liquidate.portfolio.ffn<-function(cur.per)
	{
		if(debugging) cat("      liquidate portfolio\n")
		remaining.comp.idx<-(1:NCOMPOUNDS)[compounds != "DSC" & compounds !="SLD"]
		for(m in remaining.comp.idx)
		{
			if(compounds[m]!="DSC" && compounds[m]!="SLD") 
			{
				phase.idx<-phase2index.fn(compounds[m])
				sale.per<-min(cur.per+ceiling(params$assets$sale.time[phase.idx]), HORIZON)
				mu<-params$assets$pricing.params[phase.idx,"vmu"]
				sigma<-params$assets$pricing.params[phase.idx,"vsigma"]
				mx<-params$assets$pricing.params[phase.idx,"vmx"]
				price<-compound.sale.price.fn(compounds[m],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[m]


				# here is where we adjust for uninvested compounds
				if (!invested[m])
				{
					price<-max(price-invest.cost[m],0)

				}
				#adjust for compounds that have not transitioned at all until liquidation.
				if (time.in.phase[m]==cur.per)
				{
					price<-price*.05
				}
				# update main function vars
				sell.value[m]<<-price*equity.in.compound[m]
				sales[s,phase.idx]<<-sales[s,phase.idx] + 1
				sale.times[s,cur.per]<<-sale.times[s,cur.per]+1
				cash[sale.per]<<-cash[sale.per] + sell.value[m]
				compounds[m]<<- "SLD"
				time.in.phase[m]<<-0
			}
		}
		return(NULL)
	}

	#----------------------------------	
	
	sell.compounds.to.cover.shortfall.ffn<-function(shortfall,cur.per)
	{
		#
		remaining.comp.idx<-(1:NCOMPOUNDS)[compounds != "DSC" & compounds !="SLD"]
		#cat("Phase Index: ", remaining.comp.idx, "\n")

		if (length(remaining.comp.idx) != 0)
		{
			len<-length(remaining.comp.idx)
			prices<-rep(0,len)
			for(m in 1:len)
			{
				phase.idx<-phase2index.fn(compounds[remaining.comp.idx[m]])
				sale.per<-min(cur.per+ceiling(params$assets$sale.time[phase.idx]), HORIZON)
				mu<-params$assets$pricing.params[phase.idx,"vmu"]
				sigma<-params$assets$pricing.params[phase.idx,"vsigma"]
				mx<-params$assets$pricing.params[phase.idx,"vmx"]
				price<-compound.sale.price.fn(compounds[remaining.comp.idx[m]],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[remaining.comp.idx[m]]

				
				# here is where we adjust for uninvested compounds
				if (!invested[m])
				{
					price<-max(price-invest.cost[m],0)
					
				}
				prices[m]<-price
			}
			sorted.idx<-order(prices,decreasing=T)
			total1<-0
			num1<-0
			m<-1
			while(total1<shortfall && m<=len) 
			{
				total1<-total1+prices[sorted.idx][m]
				num1<-num1+1
				m<-m+1
			}

			# update main function vars
			for(m in 1:num1)
			{
				idx<-sorted.idx[m]
				phase.idx<-phase2index.fn(compounds[remaining.comp.idx[idx]])
				sale.per<-min(cur.per+ceiling(params$assets$sale.time[phase.idx]), HORIZON)
				if(debugging>1) cat("selling to cover shortfall m-", m," idx=",idx," s=",s," sale.per=",sale.per," phase.idx=",phase.idx," price=",prices[idx],"\n")
				cash[sale.per]<<-cash[sale.per] + prices[idx]
				compounds[remaining.comp.idx[idx]]<<- "SLD"
				time.in.phase[remaining.comp.idx[idx]]<<-0
				extra.cash.from.coverage[s,sale.per]<<-extra.cash.from.coverage[s,sale.per]+prices[idx]
				sales[s,phase.idx]<<-sales[s,phase.idx]+1
				sale.times[s,cur.per]<<-sale.times[s,cur.per]+1
			}
		}
		if(debugging>1) cat("done selling to cover\n")
		return(NULL)
	}
	
	#----------------------------------	
	#----------------------------------	
	#----------------------------------
	
	if(show.progress) cat("Simulation of ",NSIMUS," paths: 0% complete\n")
	for(s in 1:NSIMUS)
	{
	
		if(show.progress) 
		{ 
			if(!(s %% prog.bar.click)) cat("Simulation ", (s/NSIMUS)*100,"% complete\n")
		}
		
		# reset variables for next path of simulation

		NCOMPOUNDS<-sum(params$simu$initial.compounds)
		
		# state of compounds
		invested   <-rep(T,NCOMPOUNDS)
		compounds <-STARTING.STATES
		time.in.phase<-rep(0,NCOMPOUNDS)
		first.cash<-params$simu$initial.cash
		sell.value<-rep(0,NCOMPOUNDS)
		equity.in.compound<-rep(params$assets$equity.stake,NCOMPOUNDS)

		# state of securities
		temp.bond.value<-bond.value
		cash			  <-c(rep(0,HORIZON))
		missed.int		  <-rep(0,length(params$bonds$nominal))
		IC.ratio          <-matrix(0,length(params$bonds$nominal)-1, NPERS)
		IC.shortfall      <-matrix(0,length(params$bonds$nominal)-1, NPERS)
		
		#record keeping 
		interest.paid	  <-matrix(0,length(params$bonds$nominal), NPERS)
		principal.paid   <-matrix(0,length(params$bonds$nominal), NPERS)

		
		if(debugging) cat("  init done\n")
		
		unpaid.svc<-0
		cash[1]<-first.cash
		cash.begin.per[s,1]<-cash[1]
		bond.value<-params$bonds$nominal
		in.default<-F
	
		invest.cost<-apply(t(compounds),2,trial.cost.fn)
		
		# temporary variables to make sure we spend only our target percentage
		cash.left.to.spend<- cash[1] - params$bonds$IC.pers*params$bonds$nominal[1]*params$bonds$coupon[1] -params$bonds$IC.pers*params$bonds$nominal[2]*params$bonds$coupon[2] 
		# number of compounds we actually buy per phase
		num.compounds <- rep(0,NSTATES)
		
		money.spent<- rep(0,NCOMPOUNDS)
		money.saved<- rep(0, NCOMPOUNDS)

		psindx<-phase2index.fn(params$assets$sell.in.phase)-1

	    for(i in 1:NCOMPOUNDS) 
		{
			cindx <- phase2index.fn(compounds[i])
			price.tmp<- invest.cost[i]+params$assets$pricing.params[cindx,"UpFront"]
			# If we have enough cash, buy it and update our initial cash

			if(psindx<1) FutureCostEst<-0
			else FutureCostEst<-params$assets$pricing.params[cindx,"FutureCostEst"]-params$assets$pricing.params[psindx,"FutureCostEst"]

			if (cash.left.to.spend >= price.tmp + FutureCostEst)
			{
				money.spent[i]<- price.tmp
				money.saved[i]<- FutureCostEst
				cash.left.to.spend <- cash.left.to.spend - price.tmp - FutureCostEst
				cash[1]<-cash[1] - price.tmp
				num.compounds[cindx]<- num.compounds[cindx] + 1
			}
			else compounds[i]<-"DSC"
		}	
		if (debugging) {
			cat('Interest Payment Savings: ', params$bonds$IC.pers*params$bonds$nominal[1]*params$bonds$coupon[1] + 3*params$bonds$nominal[2]*params$bonds$coupon[2] )
			cat(' Spent on Compounds: ', money.spent)
			cat(' Money Saved: ', money.saved)
		}
		cash[2]<-cash[1]
		cash.begin.per[s,2]<-cash[1]

		


		#----- simulate one trajectory ----
		#
		# I) For each time period
		#    1) Check for transitions
		#	 2) Apply waterfall rules
		#		A) if insufficient cash to pay this period's obligations transaction is in default
		#			i) liquidate portfolio 
		#			ii) use proceeds to pay servicing and then all P&I for A1, then P&I for A2, etc.
		#		B) if not in default
		#			i) check coverage test 
		#			ii) If coverage is not OK 
		#				a) sell enough assets to bring ratio back in line (coarse approximation)
		#			iii)Pay obligations 
		#				a) Pay servicing
		#				b) Pay P&I for A1, then for A2, etc.
		#				c) make investmensts in compounds as cash permits
		# II) If last time period
		#	1) liquidate portfolio
		#	2) Make final payements to bonds
		#	3) Residual cash goes to equity
		#
		
		A1.in.default<-F
		A2.in.default<-F
		z<-rnorm(1)
		for (i in 2:NPERS) # during life of bonds
		{
		
			if(debugging) cat("    In period ",i,"\n")
			old.compounds<-compounds
			current.cash<-cash[i]

			if(debugging>2)
			{
				cat("		List of Compounds:\n")
				for (j in 1:NCOMPOUNDS)
				{
					cat("			Compound:  Number=",j," in Status=",compounds[j],"\n")
				}
			}

			if(debugging) cat("      start transition check\n")
		    if(rho>0) dz<-rnorm(1)
			else dz<-0
			
			# ----------- first determine current state of portfolio

			for (j in 1:NCOMPOUNDS) 
			{
				old.phase<-compounds[j]
				eligible.for.transition<-(compounds[j] != "DSC" && compounds[j] != "APP" && compounds[j] != "SLD" && invested[j]==T)
				if(eligible.for.transition) 
				{
					check.for.transitions.ffn(j,cur.rho,z)
					if (compounds[j] ==params$assets$sell.in.phase) 
					{
						sell.compound.ffn(j,i)	
						if(debugging) cat("        sell compound", j, "in per",i,"\n")
					}
					else if(compounds[j]=="DSC" && old.phase!="DSC") 
					{
						withdraw.compound.ffn(old.phase,i)
						if(debugging) cat("        withdraw compound", j, "in per",i,"\n")
						time.in.phase[j]<-0

					}
					else if (compounds[j] != old.phase) #transiton occured
					{
						transition.compound.ffn(j)
						if(debugging) cat("        transition compound", j, "in per",i," from ",old.phase," to ",compounds[j],"\n")
					}
					else
					{
						time.in.phase[j]<-time.in.phase[j]+1
					}
				}		
			}
			
			if(debugging) cat("      finished transition check\n")
			
			# ----------- accounting balance

			A1.realized.vals[s,i]<-bond.value[1]
			A2.realized.vals[s,i]<-bond.value[2]
			
			#------------ next calc payments of servicing and bonds							
			if(!in.default)
			{
				if(debugging) cat("      Check for default on svc\n")
			
				svc.paid.in.full<-pay.servicing.ffn()
				if(!svc.paid.in.full) 
				{
					in.default<-T
					if(debugging) cat("SVC DEFAULT\n")
				}
			}

			#------------ next if not yet in default, check for default
			
			if(!in.default) 
			{
				
				A1.cash.required<-AMORT.SCHED[1,i]+bond.value[1]*params$bonds$coupon[1]
				A2.cash.required<-AMORT.SCHED[2,i]+bond.value[2]*params$bonds$coupon[2]
				cash.required<-A1.cash.required+A2.cash.required
			
			if(current.cash<A1.cash.required)
			{
				A1.in.default<-T
				if(bond.value[2]>0) A2.in.default<-T
			}
			else if((current.cash<A1.cash.required+A2.cash.required)&(bond.value[2]>0)) A2.in.default<-T
			if(A1.in.default || A2.in.default) in.default<-T
			else in.default<-F
			
				if(debugging) cat("      cash required= ",cash.required,"\t current.cash= ", current.cash, ": ",ifelse(in.default,"IN DEFAULT","SOLVENT"),"\n")
			}
			
			#------------ next if not in default pay P&I; if in default liquidate portfolio
			
			if (!in.default)
			{
				if(debugging) cat("        no default\n")
				#Now pay current period interest etc.

				#PAY P&I
				for(b in 1:NBONDS) # pay int
				{
					I<-params$bonds$coupon[b]*bond.value[b]
					interest.paid[b,i]<-min(I,current.cash)
					current.cash<-current.cash-interest.paid[b,i]
				}
				for(b in 1:NBONDS) #pay principal
				{
					P<-AMORT.SCHED[b,i]
					principal.paid[b,i]<-min(P,current.cash)
					current.cash<-current.cash-principal.paid[b,i]
					bond.value[b]<-bond.value[b]-principal.paid[b,i]
					if(bond.value[b]<0.0001) bond.value[b]<-0
				}
					
				#------------ next check coverage
				
				for(b in 1:NBONDS) #calc IC coverage
				{
					if(bond.value[b]>0)
					{
						IC.ratio[b,i]<-ic.test.result.ffn(b,i,current.cash+cash[i+1]+cash[i+2]) 
						if(debugging) cat("           IC test for tranche",b,":",IC.ratio[b,i],"; bond value: ",bond.value[b],"\n")
						payment.for.sr.tranches<-0
						if(b>1) 
						{ 
							for(bb in 1:(b-1))
							{
								btemp<-bond.value[bb]
								for(m in 1:ceiling(max(params$assets$sale.time)))
								{
									payment.for.sr.tranches<-payment.for.sr.tranches+AMORT.SCHED[bb,i+m]+params$bonds$coupon[bb]*btemp+params$bonds$servicing*btemp
									btemp<-btemp-AMORT.SCHED[bb,i+m]
								}
							}
						}
						if (IC.ratio[b,i]==0)
						{
							sched.svc<-unpaid.svc
							bv<-bond.value[b]
							sched.P <- 0
							sched.I <- 0
							for(m in 1:params$bonds$IC.pers)
							{
								sched.P<- sched.P + AMORT.SCHED[b,i+m]
								sched.I<- sched.I + params$bonds$coupon[b]*bv
								sched.svc<-sched.svc+params$bonds$servicing*bv
								bv<-bv-AMORT.SCHED[b,i+m]		
							}
							cost.due<-sched.P+sched.I+sched.svc
						}
						else
						{	
							cost.due<-((current.cash+cash[i+1]+cash[i+2]-payment.for.sr.tranches)/IC.ratio[b,i])
						}
						gap.pct<-max(params$bonds$interest.coverage[b]-IC.ratio[b,i],0)
						IC.shortfall[b,i]<-(params$bonds$interest.coverage[b]*cost.due) - (current.cash+cash[i+1]+cash[i+2]-payment.for.sr.tranches)
					
						if(debugging>1) cat("              Bond ",b," shortfall=",IC.shortfall[b,i],"\n")
					}
					else IC.shortfall[b]<-0
				}

				#------------ check equity svc coverage

				eq.svc.due<-unpaid.svc
				for (k in 1:ceiling(max(params$assets$sale.time)))
				{
					eq.svc.due<-eq.svc.due + bond.value[length(bond.value)]*params$bonds$servicing
				}
				eq.shortfall<- eq.svc.due - current.cash
				if(debugging>2)
				{
					cat("		eq.svc.coverage=",eq.svc.due,".  eq.shortfall=", eq.shortfall, "\n")
				}
				
				#------------ next if IC too low, sell compounds to cover

				max.shortfall<-max(IC.shortfall[,i],eq.shortfall)
				if(debugging>2) cat("ic shortfall =",IC.shortfall[,i]," eq shortfall=",eq.shortfall)
				if(max.shortfall > 0) 
				{
					if(debugging) cat("          hit shortfall.  maxshortfall=",max.shortfall,"\n")
					sell.compounds.to.cover.shortfall.ffn(max.shortfall,i)
					OK.to.fund<-F
				}	
				else 
				{
					if(debugging) cat("        no shortfall\n")
					OK.to.fund<-T
				}
				
				#------------ next if IC is OK fund next phases of research for compounds 
				compounds.to.fund[s,i]<-sum(compounds != "DSC" & compounds != "APP" & compounds != "SLD" & !invested)

				if(OK.to.fund)
				{
					if(i<NPERS)
					{
						if(i<NPERS-params$bonds$IC.per) 
						{	next.pers<-(i+1):(i+params$bonds$IC.per)
							num<-params$bonds$IC.pers
						}
						else if (i<(NPERS-params$bonds$IC.per-1))
						{
							next.pers<-(i+1):(i+params$bonds$IC.per-1)
							num<-params$bonds$IC.per-1
						}
						else
						{
							next.pers<-i+1
							num<-1
						}
							
						
						cash.required.for.future<-sum(AMORT.SCHED[,next.pers])+
										num*(
												sum(params$bonds$coupon[1:NBONDS]*bond.value[1:NBONDS])+(params$bonds$servicing.rate*sum(bond.value))
											)
						
						cash.to.invest<-max(current.cash-cash.required.for.future,0)
						if(debugging>1) cat("        Investing up to: ",cash.to.invest," and reserving ",cash.required.for.future," current.cash=",current.cash,"\n")
		
						if(cash.to.invest>0)
						{
							compounds.to.fund.idx<-(1:NCOMPOUNDS)[!invested & compounds != "DSC" & compounds != "APP" & compounds !="SLD"] 								#index of compounds that need funding
							cash.spent<-0
							for(k in compounds.to.fund.idx)
							{
								if(invest.cost[k] <= cash.to.invest) 
								{
									invested[k]<-T
									cash.to.invest<-cash.to.invest-invest.cost[k]
									cash.spent<-cash.spent+invest.cost[k]
									compounds.funded[s,i]<-compounds.funded[s,i]+1
									if(debugging>1) cat("        funded compound ",k,"@ ",invest.cost[k],"\n")
								}
							}
							current.cash<-current.cash-cash.spent 
							cash.for.investment[s,i]<-cash.for.investment[s,i] + cash.spent
						}
					}
				}
			}
			else # already in default
			{
				if(debugging) cat("      in default\n")
				liquidate.portfolio.ffn(i)
				pay.servicing.ffn() 
				#PAY P&I
				if (debugging) cat("         current cash=",current.cash," current bond value",bond.value,"\n")
				for(b in 1:NBONDS) # pay down bonds sequentially
					{
						if(current.cash>0)
						{
							I<-min(current.cash,params$bonds$coupon[b]*bond.value[b])
							interest.paid[b,i]<-I
							current.cash<-current.cash-I
							P<-min(current.cash,bond.value[b])
							principal.paid[b,i]<-P
							bond.value[b]<-bond.value[b]-P
							if(bond.value[b]<0.0001) bond.value[b]<-0
							if (debugging) cat("        paying interest=",I," paying redemption=",P," new bond value=",bond.value[b],"\n")
							current.cash<-current.cash-P
						}
					}
				# Check to see if A1 defaults	
				if (A1.in.default==F && A2.in.default==T)
				{
					if (bond.value[1] > 0) {
						A1.in.default<-T
					}
				}
					
					
			}
			cash[i]<-current.cash
			if(i!=NPERS) 
			{
				#cash left over at end of period accrues interest
				cash[i+1]<-cash[i+1]+(current.cash*(1+params$bonds$cash.accrual.int.rate))
				cash.begin.per[s,i+1]<-cash[i+1]
			}
			
				
		}	##END TIMESTEP ITERATION#####
		
		final.compounds = final.compounds + c(sum(compounds=='DSC'), sum(compounds=='PRE'), sum(compounds=='P1'), sum(compounds=='P2'), sum(compounds=='P3'), sum(compounds=='NDA'), sum(compounds=='APP'))/NSIMUS
		
		liquidate.portfolio.ffn(NPERS)
		for(i in NPERS:(HORIZON-1)) 
		{
			current.cash<-cash[i]
			pay.servicing.ffn()
			cash[i]<-current.cash
			cash[i+1]<-cash[i]+cash[i+1] 
			cash.begin.per[s,i+1]<-cash[i+1]
		}
		cash.realized[s,]<-cash
		compounds.bought[s,]<-num.compounds

		A1.paid[s,]<-principal.paid[1,]+interest.paid[1,]
		A2.paid[s,]<-principal.paid[2,]+interest.paid[2,]
		A1.defaults[s]<-A1.in.default
		A2.defaults[s]<-A2.in.default
		return.on.equity[s]<-max((tail(cash,1) - params$bonds$nominal["EQ"])/(params$bonds$nominal["EQ"]),-1)
		if(debugging>2) cat("s=",s," tail=",tail(cash,1)," nominal=",params$bonds$nominal["EQ"], "ROE=", return.on.equity[1:s], " ROE Annualized=", ((1+return.on.equity[1:s])^(1/10))-1, "\n")
	}	
	
		###END SIM COUNT LOOP#####
	
	ret<-list(
			cash.begin.per=cash.begin.per,
			cash=cash.realized,
			cash.for.investment=cash.for.investment,
			A1.bals=A1.realized.vals,
			A2.bals=A2.realized.vals,
			amort.sched=AMORT.SCHED,
			A1.payment=A1.paid,
			A2.payment=A2.paid,
			IC.ratio=IC.ratio,
			ROE=return.on.equity,
			sale.phases=sales,
			withdrawal.phases=withdrawals,
			sale.times=sale.times,
			withdrawal.times=withdrawal.times,
			extra.cash.for.coverage=extra.cash.from.coverage,
			servicing=history.service,
			compounds.to.fund=compounds.to.fund,
			compounds.funded=compounds.funded,
			compounds.initially.bought=compounds.bought,
			params=params,
			final.sale.values=sell.value,
			compounds.left = final.compounds,
			A1.defaults = A1.defaults,
			A2.defaults = A2.defaults
		)
	
	return(ret)
}




##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


init.params.fn<-function()

#initializes all parameters used by the simulation. Contains all default values used.
#Rationale behind these numbers is explained in the Supplementary Information section of the paper "Commercializing biomedical research through securitization tecniques" (Fernandez, Stein, Lo; Nature Biotechnology; October 2012)

{

	# ------- ASSET PARAMETERS

	a.params<-list(
		rho=0.2,
		trans.prob=matrix(c(
		    #DSC    PRE	  P1        P2         P3         NDA        APP
		    #
			1.0000,  0,   0,        0,         0,         0,         0,          #DSC
			0.1550,  0.5, 0.345,    0,         0,         0,         0,          #PRE
			0.0532,  0,   0.8079,   0.1334,    0.0053,    0.0002,    0,          #P1
			0.0851,  0,   0,    	0.8447,    0.0668,    0.0029,    0.0006,     #P2
			0.0626,  0,   0,        0,         0.8484,    0.0682,    0.0208,     #P3
			0.0217,  0,   0,        0,         0,         0.5667,    0.4116,     #NDA
			0,		 0,   0,        0,         0,         0,         1           #APP
          	),
         	byrow=T,
         	nrow=7,ncol=7, 
         	dimnames=list
         	(
         			c("DSC","PRE","P1","P2","P3","NDA","APP"),
         			c("DSC","PRE","P1","P2","P3","NDA","APP")
         	)
        ),  
		pricing.params=matrix(c(
	   #     vmu     vsimga   vmx   UpFront   MileStone    mu       sigma      max   FutureCostEst
                 0,       1,     0,      0,        0,          0,       0,          0,       0,      #DSC
              2.36,   0.939,   100,    2.5,      1.3,      1.527,   0.785,         20,     134,       #PRE
              2.96,   0.939,   250,    7.5,      3.8,      2.725,   0.732,         50,     121,       #P1
              4.00,   0.939,   500,    20.1,     10.0,     3.650,   0.796,        120,      85,      #P2   
              5.80,   0.939,  1000,    75.3,     37.6,     5.063,   0.633,        500,       0,      #P3
              7.355,  0.939,  2500,    0,          0,          0,       0,          0,       0,       #NDA
              7.24,   0.939,  5000,    0,          0,          0,       0,          0,       0        #APP
            ),
            byrow=T,
            nrow=7,ncol=9,
            dimnames=list
         	(
         			c("DSC","PRE","P1","P2","P3","NDA","APP"),
         			c("vmu","vsigma","vmx","UpFront","Milestone","mu","sigma","max","FutureCostEst")
         	)

		),

		sell.in.phase="P2",
		sale.time=c(DSC=1.5,PRE=1.5,P1=1.5,P2=1.5,P3=1.5,NDA=1.5,APP=1.5),
		equity.stake = 0.85
	)	
	
	# ------- BOND PARAMETERS	

	temp.sched<-rep(0,)
	
	b.params<-list(
		capital.structure=c(A1=0.25,A2=0.25,EQ=0.5),
		nominal=NULL,
		interest.coverage=c(A1=2,A2=3,EQ=0),
		IC.pers=2,
		amort.timing=matrix(c(
			 5,  8,
			 9, 12
			),
			byrow=T,
			nrow=2,ncol=2,
			dimnames=list
         	(
         			c("A1","A2"),
         			c("start","stop")
         	)
		),
		coupon=c(A1=0.05/2,A2=0.08/2,EQ=0),
		servicing.rate=0.0025,
		svc.accrual.int.rate=0.07/2,
		cash.accrual.int.rate=.01/2
	)

# ------- SIMU PARAMETERS

	s.params<-list(
		NSIMUS=50000,
		TIMESTEPS=max(b.params$amort.timing)+1,
		initial.cash=5000,
		initial.compounds=c(DSC=0,PRE=100,P1=100,P2=0,P3=0,NDA=0,APP=0) 
	)

	b.params$nominal<-s.params$initial.cash*b.params$capital.structure
	
	return(list(simu=s.params,assets=a.params,bonds=b.params))
}



##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

calc.amort.pmt.due.fn<-function(per,a.start,a.end,orig.par, cur.par)
{
	
	# Calculate principal payment due in period per
	
	
	amort.per<-a.end-a.start+1
	if ( per >= a.start && per<=a.end )
	{
		if (orig.par/amort.per < cur.par) pmt<-orig.par/amort.per
		else pmt<-cur.par
	}
	else pmt<-0
	return(pmt)
}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

compound.sale.price.fn<-function(comp.phase,per,mu,sigma,mx,rho,z) 
{
	# Calculate value of compounds sold

	if(rho==0) {
		 v<-min(rlnorm(1,mu,sigma),mx)
	}
	else
	{
		ej<-rnorm(1)
		Z<-(sqrt(rho)*z)+(sqrt(1-rho)*ej)
		X<-Z*sigma+mu
		v<-min(exp(X),mx)
		
	}
	
	return(v)

}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

determine.current.state.fn<-function(p,dist)
{
	# determines whether compounds transition or not to a new phase

	cdist<-cumsum(dist)
	len<-length(dist)
	cdist[len]<-1
	i<-1
	cdf<-cdist[1]

	while(cdf<p) 
	{
		i<-i+1
		cdf<-cdist[i]
	}		

	return(names(dist[i]))
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

phase2index.fn<-function(phase)
{
	#
	# Convert character string representation of phase into an index
	#      phase is one of "DSC", "P1","P2","P3","NDA", "APP"
	#
	return(grep(phase,c("DSC","PRE","P1","P2","P3","NDA", "APP")))
}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

plot.standard.diagnostics.fn<-function(results) 
{
	# plot graph to display main results of simulation

	par(mfrow=c(3,2))
	par(cex=0.5)
	plot.trajectories.fn(results$cash,main="Cash - Quantiles",quant=T)
   	ROE.raw<-results$ROE
	NYEARS<-length(results$cash[1,])/2
    	ROE.annualized<-((1+ROE.raw)^(1/NYEARS))-1
	hist(ROE.annualized,main="ROE.annualized",col=4,xlab="")
	#
	plot.trajectories.fn(results$A1.bals,main="A1 balance - Quantiles",quant=T)
	plot.trajectories.fn(results$A2.bals,main="A2 balance - Quantiles",quant=T)
	#
    sale.phases<-colMeans(results$sale.phases)
    withdrawal.phases<-colMeans(results$withdrawal.phases)
   	col.names<-names(withdrawal.phases)
   	row.names<-c("Sales:","WD:")
   	exits<-matrix(c(sale.phases,withdrawal.phases),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   	barplot(exits,space=c(0,0.5),col=c(3,2),beside=T,main="Mean # compounds sold (green) or withdrawn (red) in phase")

   	#
   	sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
   	col.names<-names(withdrawal.times)
   	exit.times<-matrix(c(sale.times,withdrawal.times),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   	barplot(exit.times,space=c(0,0.5),col=c(3,2),beside=T,main="Mean # compounds sold (green) or withdrawn (red) in period")
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

plot.trajectories.fn<-function(paths,n=0,quant=F,...) 
{
	if(quant)
	{
		series<-apply(paths,2,FUN=quantile)
	}
	else
	{
		series<-paths
	}
	len<-length(series[1,])
	N<-length(series[,1])
	if(n==0) n<-N
	mx<-max(series)
	mn<-min(series)

	plot(1:len,smooth(unlist(series[1,1:len])),ylab="",xlab="Period",type="l",ylim=c(mn,mx),...)
	for(i in 2:min(n,N)) lines(1:len,smooth(unlist(series[i,1:len])),type="l",col=i+7)
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

summarize.results.fn<-function(results,plot=T) 
{

    # displays main results from simulation

    HORIZON<-length(results$cash[1,])
    NPERS<-length(results$A1.bals[1,])
    NYEARS<-HORIZON/2
    NCOMPOUNDS<-sum(results$params$simu$initial.compounds)
    sale.phases<-colMeans(results$sale.phases)
    withdrawal.phases<-colMeans(results$withdrawal.phases)
    sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
   col.names<-names(withdrawal.phases)
   row.names<-c("Sales:","WD:")
   exits<-matrix(c(sale.phases,withdrawal.phases),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
   col.names<-names(withdrawal.times)
   exit.times<-matrix(c(sale.times,withdrawal.times),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   row.names<-c("Funds needed","Funds invested")
   funds.needed<-colMeans(results$compounds.to.fund)
   funds.done<-colMeans(results$compounds.funded)
   funding<-matrix(c(funds.needed,funds.done),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
    A1.gt.0<-results$A1.defaults #(results$A1.bals[,NPERS]>0)
    A2.gt.0<-results$A2.defaults #(results$A2.bals[,NPERS]>0)
    p1<-mean(A1.gt.0)
    p2<-mean(A2.gt.0)
    el1<-(mean(results$A1.bals[,NPERS])/params$bonds$nominal["A1"])
    el2<-(mean(results$A2.bals[,NPERS])/params$bonds$nominal["A2"])
    loss.stats<-matrix(c(p1,p2,el1,el2),2,2,dimnames=list(c("PD","EL"),c("A1","A2")),byrow=T)
    PD<-c(A1=p1,A2=p2)
    EL<-c(A1=el1,A2=el2)
    ROE.raw<-results$ROE
    ROE.annualized<-((1+ROE.raw)^(1/NYEARS))-1
    ROE.mean<-mean(ROE.raw)
    ROE.mean.a<-mean(ROE.annualized)
    ROE.quant<-quantile(ROE.raw)
    ROE.quant.a<-quantile(ROE.annualized)
    ROE.q<-matrix(c(ROE.quant,ROE.quant.a),2,5,byrow=T,dimnames=list(c("TOT","ANN"),c("0","25","median","75","100")))
    p.EQ.wipeout<-mean(ROE.annualized==-1)
    p.EQ.loss<-mean(ROE.annualized<0)
    p.EQ.pos<-mean(ROE.annualized>=0)
    p.EQ.05<-mean(ROE.annualized>0.05)
    p.EQ.10<-mean(ROE.annualized>=0.1)
    p.EQ.15<-mean(ROE.annualized>0.15)
    p.EQ.25<-mean(ROE.annualized>0.25)
    EQ.probs<-matrix(
    c(p.EQ.wipeout,p.EQ.loss,p.EQ.pos,p.EQ.05,p.EQ.10,p.EQ.15,p.EQ.25),
    1,7,
    dimnames=list( c("p(x)"),
    c("EQ=0","EQ.loss","EQ.pos","EQ>0.05","EQ>0.10","EQ>0.15","EQ>0.25")),
    byrow=T
    )
    ROE<-matrix(c(ROE.mean,ROE.mean.a),1,2, byrow=T,dimnames=list(c("E[ROE]"),c("TOT","ANN")))
    cat("\n\nv==================================v\n")
    cat("\n# Simu:",params$simu$NSIMU,". Horizon: ",NYEARS,"years.\n")
    cat("\n--------- ASSET  ANALYSIS ----------\n\n")
    cat("Initial target portfoilio contains ",NCOMPOUNDS," compounds:\n")
    print(results$params$simu$initial.compounds)
    cat("\nMean number of compounds initially purchased:\n")
    print(colMeans(results$compounds.initially.bought))
    cat("\nMean number of compounds exiting in each state:\n")
    print(exits)
    cat("\nMean number of compounds exiting in each period:\n")
    print(exit.times)
    cat("\nMean number of compounds funded in each period:\n")
    print(funding)    
    cat("\n--------- EQUITY ANALYSIS ----------\n\n")
    print(round(ROE, 3))
    cat("\nquant(ROE)\n")
    print(round(ROE.q,3))
    cat("\n")
    print(round(EQ.probs,5))
    cat("\n---------  BOND ANALYSIS  ----------\n\n")
    print(round(loss.stats,5))
    cat("\n\n^==================================^\n\n")

    
    if(plot) plot.standard.diagnostics.fn(results)

}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

trial.cost.fn<-function(comp.phase)
{
	# 
	# Determine cost of funding trials (stochastically) for phase comp.phase
	#      comp.phase is one of "DSC","P1","P2","P3","NDA", "APP"
	#

	p<-comp.phase
	if(p=="DSC" || p=="NDA" || p=="APP" || p=="SLD") return(0)
	else 
	{
		i<-phase2index.fn(comp.phase)
		mu<-params$asset$pricing.params[i,"mu"]
		sigma<-params$asset$pricing.params[i,"sigma"]
		mx<-params$asset$pricing.params[i,"max"]		
		raw.cost<-rlnorm(1,mu,sigma)
		cost<-min(raw.cost,mx)
	    return(cost)
	}
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
######################################################### END OF CODE ############################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################



#COPYRIGHT 2012
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
